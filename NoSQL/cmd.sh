# Redis（Key-Value Store）
# Redis 适用于 缓存、会话存储、排行榜、计数器 等场景。


# 练习场景：用户会话管理
# 你需要存储用户的 登录状态 和 访问令牌，并设置 过期时间（TTL）。
# Redis 适合存储 频繁访问的数据，但不是理想的持久存储。

docker exec -it redis_container redis-cli

# 当用户成功登录时，应用创建会话数据
# 存储用户身份信息和唯一访问令牌
# 应用将令牌返回给客户端(通常作为cookie或JWT)
SET user:1001 '{"username": "ananya", "status": "active", "token": "abc123"}'
# 设置会话过期时间 (EXPIRE 命令),设置60秒后自动过期，增强安全性
# 防止无效会话长期存在,实际应用中可能设置30分钟或更长
EXPIRE user:1001 60
GET user:1001 # 用户每次请求受保护资源时,应用从请求中提取令牌，使用它查找会话,验证会话存在且有效
DEL user:1001 # 用户点击"退出登录"时，立即删除会话,使令牌立即失效，增强安全性


```
应用服务访问Redis: 在这种会话管理架构中，应用服务（后端服务器）访问Redis，而不是客户端应用：

Redis在这个过程中只是一个存储介质，它存储由应用服务生成的token和会话数据，但不参与token的生成过程。

┌─────────────┐         ┌─────────────┐         ┌─────────────┐
│             │  HTTP   │             │  Redis  │             │
│  用户客户端  │◄────────►│  应用服务   │◄────────►│  Redis服务  │
│ (浏览器/App) │  请求   │  (后端)     │  命令   │             │
└─────────────┘         └─────────────┘         └─────────────┘
       ▲                       │
       └───────────────────────┘
           返回token给客户端
```

典型流程
用户登录:

用户通过浏览器/App输入凭据
应用服务验证凭据
应用服务生成会话数据，通过Redis命令存入Redis
应用服务将token返回给客户端
后续请求:

客户端发送请求时附带token
应用服务从Redis获取会话数据验证token
根据验证结果决定是否处理请求
Redis作为一个独立服务，只与应用服务通信，不会直接与客户端通信，这是出于安全和架构设计考虑。

Redis缓存优势在身份验证流程中
Redis的缓存优势 - 会话管理模式
首次登录 → 查询用户数据库 → 验证用户 → 存入Redis → 返回token
后续请求 → 查询Redis → 验证token → 处理请求

优势： 
只在首次登录时查询主数据库
后续请求只查询高速Redis缓存
验证速度极快(微秒级)
减轻主数据库压力
身份验证更高效

Token生成流程
在首次登录过程中，token是由应用服务（后端）生成的，不是由Redis生成的。

详细流程
用户向应用服务器提交用户名和密码
应用服务验证凭据（通常与用户数据库比对）
应用服务生成唯一token
可能使用UUID
或生成JWT (JSON Web Token)
或其他安全随机生成方法
应用服务将用户信息和token存入Redis
应用服务将token返回给客户端
Redis在这个过程中只是一个存储介质，它存储由应用服务生成的token和会话数据，但不参与token的生成过程。

应用服务负责所有的业务逻辑，包括身份验证和token生成，而Redis只负责高性能存储和检索。













